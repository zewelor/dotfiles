#!/bin/zsh

# Exit immediately if a command exits with a non-zero status,
# if using an undefined variable, or if any command in a pipeline fails.
set -euo pipefail

# Determine the directory where the script is located.
SCRIPT_DIR="$(cd "$(dirname "${(%):-%x}")" && pwd)"
BASE_DIR="$SCRIPT_DIR"
HOME_DIR="$HOME"
CONFIG_DIR="$HOME_DIR/.config"

# Optional font installer executable that mirrors the Nerd Font helper.
FONT_INSTALLER="$BASE_DIR/install-font"

# Common paths and URLs.
VAULT_URL="https://vault.8567153.xyz/v1/shell_envs/data"
VAULT_KEYS=("envs.zsh")

# Function to check if a command exists.
has() { command -v "${1:-}" >/dev/null 2>&1; }

# Function to check if the profile is desktop.
is_desktop() {
  [[ "${DOTFILES_PROFILE:-server}" == "desktop" ]]
}

# Resolve a suitable browser command, mirroring .zsh/webapps.zsh logic.
resolve_browser_cmd() {
  local detected="${BROWSER:-}"

  if [[ -z "$detected" ]]; then
    local default_desktop
    default_desktop=$(xdg-settings get default-web-browser 2>/dev/null || true)

    local desktop_path=""
    if [[ -n "$default_desktop" ]]; then
      if [[ -f "/usr/share/applications/$default_desktop" ]]; then
        desktop_path="/usr/share/applications/$default_desktop"
      elif [[ -f "$HOME_DIR/.local/share/applications/$default_desktop" ]]; then
        desktop_path="$HOME_DIR/.local/share/applications/$default_desktop"
      fi
    fi

    if [[ -n "$desktop_path" ]]; then
      local exec_line
      exec_line=$(grep -m1 '^Exec=' "$desktop_path" || true)
      if [[ -n "$exec_line" ]]; then
        detected=$(print -r -- "${exec_line#Exec=}" | sed -E 's/ ?%[a-zA-Z]//g')
      fi
    fi

    if [[ -z "$detected" ]]; then
      local browser_candidates=("brave-browser-stable" "brave-browser" "google-chrome-stable" "google-chrome" "chromium" "chromium-browser" "brave" "chromium" "firefox")
      for candidate in "${browser_candidates[@]}"; do
        if has "$candidate"; then
          detected="$candidate"
          break
        fi
      done
    fi

    detected="${detected:-xdg-open}"
  fi

  # Validate command availability (first word only to allow flags/paths)
  local first_word="${detected%% *}"
  if ! has "$first_word"; then
    echo ""
    return
  fi

  echo "$detected"
}

# Function to check if the shell is interactive.
is_interactive() {
  [[ -t 0 ]]
}

# Function to print banners for major steps.
print_banner() {
  local title="$1"
  local line="========================================"
  printf "\n%s\n%s\n%s\n" "$line" "$title" "$line"
}

# Function to install symlinks using stow.
install_with_stow() {
  local stow_opts=("$@")

  echo "Running stow with: ${stow_opts[*]}"
  if ! stow -v "${stow_opts[@]}" -n; then
    echo "Error: Stow dry run failed with options: ${stow_opts[*]}" >&2
    exit 1
  fi

  # Auto-apply in non-interactive mode
  if ! is_interactive; then
    echo "Non-interactive mode detected. Applying changes automatically..."
    stow -v "${stow_opts[@]}"
    return
  fi

  read -r "response?Do you want to apply the changes? [y/N] "
  case "$response" in
    [Yy]*)
      echo "Applying changes..."
      stow -v "${stow_opts[@]}"
      ;;
    *)
      echo "Changes were not applied."
      ;;
  esac
}

# Function to force-refresh the font cache when fonts are (re)linked.
refresh_font_cache() {
  local font_dir="$HOME_DIR/.local/share/fonts"

  if ! has "fc-cache"; then
    echo "fc-cache not available; cannot refresh font cache." >&2
    exit 1
  fi

  if [[ ! -d "$font_dir" ]]; then
    echo "Font directory $font_dir not found; cannot refresh font cache." >&2
    exit 1
  fi

  print_banner "Refreshing font cache..."
  fc-cache -f "$font_dir"
}

# Function to add secret environment variables from Vault.
add_secret_envs_from_vault() {
  if ! is_interactive; then
    echo "Skipping secret envs setup in non-interactive mode."
    return
  fi

  read -r "response?Would you like to add secret envs from Vault? [y/N] "
  if [[ "$response" =~ ^[Yy]$ ]]; then
    read -rs "VAULT_TOKEN?Please provide your Vault token: "
    echo

    mkdir -p "$HOME_DIR/.zshrc.d"

    for key in "${VAULT_KEYS[@]}"; do
      echo "Fetching data for key: $key"
      (
        IFS=$'\n\t'
        local response
        response=$(curl -sf -H "X-Vault-Token: $VAULT_TOKEN" -X GET "$VAULT_URL/$key") || {
          echo "Failed to fetch data for $key from Vault." >&2
          exit 1
        }

        echo "# Generated with install script from dotfiles" > "$HOME_DIR/.zshrc.d/$key"
        echo "$response" | jq -r '.data.data | to_entries[] | "export \(.key)=\(.value)"' >> "$HOME_DIR/.zshrc.d/$key"
      )

      echo "Environment variables for $key have been saved to $HOME_DIR/.zshrc.d/$key"
    done
  else
    echo "Skipped adding secret environment variables from Vault."
  fi
}

# Function to configure Git conflict style based on git version.
configure_git_conflict_style() {
  local required_git_version="2.35.0"
  local current_version
  current_version=$(git --version | awk '{print $3}')

  autoload -Uz is-at-least
  if is-at-least "$required_git_version" "$current_version"; then
    echo "Git version ($current_version) supports zdiff3."
    git config --file "$HOME_DIR/.gitconfig.local" merge.conflictstyle "zdiff3"
    echo "Set 'merge.conflictstyle' to 'zdiff3' in $HOME_DIR/.gitconfig.local."
  fi
}

# Function to setup Atuin configuration.
setup_atuin() {
  print_banner "Setting up Atuin configuration..."
  mkdir -p "$CONFIG_DIR/atuin/"
  local src="$BASE_DIR/.config/atuin/config.toml"
  local dst="$CONFIG_DIR/atuin/config.toml"

  # Avoid failing when src and dst already resolve to the same path (e.g., stowed .config).
  if [[ -e "$dst" ]] && [[ "$(readlink -f "$dst")" == "$(readlink -f "$src")" ]]; then
    echo "Atuin config already linked; skipping."
    return
  fi

  ln -sfn "$src" "$dst"
}

# Function to ensure SSH directories exist.
setup_ssh() {
  print_banner "Ensuring SSH configuration directory exists..."
  mkdir -p "$HOME_DIR/.ssh/config.d/"
}

# Function to install custom desktop entries defined in webapps/apps.tsv.
setup_desktop_entries() {
  set -euo pipefail

  if ! is_desktop; then
    echo "Skipping desktop entry installation on non-desktop profile."
    return
  fi

  local config="$BASE_DIR/webapps/apps.tsv"
  if [[ ! -f "$config" ]]; then
    echo "No desktop entry config found at $config; skipping."
    return
  fi

  local applications_dir="${XDG_DATA_HOME:-$HOME_DIR/.local/share}/applications"
  local icon_dir="$applications_dir/icons"
  mkdir -p "$applications_dir" "$icon_dir"

  local desktop_installer=""
  if has "desktop-file-install"; then
    desktop_installer="desktop-file-install"
  else
    echo "desktop-file-install not found; will write .desktop files directly."
  fi

  local browser_cmd
  browser_cmd=$(resolve_browser_cmd)

  if [[ -z "$browser_cmd" ]]; then
    echo "No supported browser found (set BROWSER or install Brave/Chrome/Chromium); skipping desktop entries."
    return
  fi

  print_banner "Installing desktop entries"
  [[ -o xtrace ]] && echo "DEBUG xtrace before loop"

  local global_flags="${DOTFILES_BROWSER_FLAGS:-}"
  local enable_wayland="${DOTFILES_CHROMIUM_WAYLAND:-1}"
  local desired_slugs=()

  while IFS='|' read -r name slug app_url icon_filename extra_flags _; do
    # Skip comments/empty lines
    if [[ -z "${name// }" ]] || [[ "${name:0:1}" == "#" ]]; then
      continue
    fi

    if [[ -z "$slug" || -z "$app_url" ]]; then
      echo "Skipping entry with missing slug or app_url: $name"
      continue
    fi

    desired_slugs+=("$slug")

    local icon_name="dotfiles-$slug"
    local desktop_file="$applications_dir/dotfiles-$slug.desktop"
    local tmpdir tmpfile
    tmpdir=$(mktemp -d -t "dotfiles-$slug.XXXXXX")
    tmpfile="$tmpdir/dotfiles-$slug.desktop"

    local exec_cmd="$browser_cmd --new-window --app=$app_url --name=${name// /\\ } --class=$slug"
    if [[ "$enable_wayland" == "1" ]]; then
      exec_cmd+=" --ozone-platform=wayland"
    fi
    if [[ -n "$global_flags" ]]; then
      exec_cmd+=" $global_flags"
    fi
    if [[ -n "$extra_flags" ]]; then
      exec_cmd+=" $extra_flags"
    fi

    if [[ -z "$icon_filename" ]]; then
      echo "Missing icon filename for $slug (column 4 in $config)."
      return 1
    fi

    local repo_icon="$BASE_DIR/webapps/icons/$icon_filename"
    local installed_icon="$icon_dir/${icon_name}.png"
    if [[ ! -f "$repo_icon" ]]; then
      echo "Icon file '$icon_filename' not found in webapps/icons for $slug."
      return 1
    fi

    install -m 0644 "$repo_icon" "$installed_icon"

    cat > "$tmpfile" <<EOF
[Desktop Entry]
Version=1.0
Name=$name
Comment=$name (PWA)
Exec=$exec_cmd
Terminal=false
Type=Application
Categories=Network;
Icon=$icon_name
StartupWMClass=$slug
StartupNotify=true
EOF

    if [[ -n "$desktop_installer" ]]; then
      "$desktop_installer" --dir "$applications_dir" --mode 0644 "$tmpfile"
    else
      install -m 0644 "$tmpfile" "$desktop_file"
    fi
    rm -rf "$tmpdir"

    echo "Installed dotfiles-$slug.desktop using browser: $browser_cmd"
  done < "$config"

  print_banner "Checking stale desktop entries"
  setopt localoptions null_glob
  local to_remove=()
  for file in "$applications_dir"/dotfiles-*.desktop; do
    local slug
    slug=${file##*/dotfiles-}
    slug=${slug%.desktop}
    local found=false
    for desired in "${desired_slugs[@]}"; do
      if [[ "$slug" == "$desired" ]]; then
        found=true
        break
      fi
    done
    if [[ "$found" == false ]]; then
      to_remove+=("$file")
    fi
  done

  if (( ${#to_remove[@]} )); then
    echo "Found stale dotfiles desktop entries:"
    printf ' - %s\n' "${to_remove[@]}"
    if is_interactive; then
      read -r "response?Remove them now? [y/N] "
      if [[ "$response" =~ ^[Yy]$ ]]; then
        rm -f "${to_remove[@]}"
        echo "Removed stale entries."
      else
        echo "Leaving stale entries in place."
      fi
    else
      echo "Non-interactive mode: not removing stale entries."
    fi
  fi
}

# Function to install desktop-specific tools via mise.
setup_mise_desktop_tools() {
  if ! has "mise"; then
    echo "mise not found; skipping mise desktop tools."
    return
  fi

  print_banner "Installing desktop tools via mise..."
  mise use -g gem:tmuxinator
}

# Function to setup Claude Code configuration (manual symlinks, stow ignores .claude).
setup_claude() {
  print_banner "Setting up Claude Code configuration..."
  local claude_dir="$HOME_DIR/.claude"
  local dotfiles_claude="$BASE_DIR/.claude"

  mkdir -p "$claude_dir"

  # Symlink all files except settings.local.json (machine-specific)
  for src in "$dotfiles_claude"/*; do
    local file
    file=$(basename "$src")

    # Skip local settings (machine-specific)
    [[ "$file" == "settings.local.json" ]] && continue

    local dst="$claude_dir/$file"

    if [[ -L "$dst" ]] && [[ "$(readlink -f "$dst")" == "$(readlink -f "$src")" ]]; then
      echo "$file already linked; skipping."
      continue
    fi

    # Remove existing file/symlink if present
    [[ -e "$dst" || -L "$dst" ]] && rm -f "$dst"

    ln -s "$src" "$dst"
    echo "Linked $file -> $src"
  done
}

# Function to setup Vim autoload directories and plugins.
setup_vim() {
  print_banner "Setting up Vim..."
  mkdir -p "$HOME_DIR/.vim/"{autoload,undo,swapfiles,backupfiles}
  curl -fsSLo "$HOME_DIR/.vim/autoload/plug.vim" --create-dirs "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
  vim +PlugInstall +qall
}

# Function to install Neovim plugins via lazy.nvim while Neovim is available.
setup_nvim_plugins() {
  local nvim_log
  nvim_log=$(mktemp -t install-nvim-sync.XXXXXX)

  print_banner "Installing Neovim plugins via lazy.nvim..."
  if nvim --headless -c 'Lazy! sync' -c 'qa' >"$nvim_log" 2>&1; then
    rm -f "$nvim_log"
    return
  fi

  echo "Neovim lazy sync failed; output follows:" >&2
  cat "$nvim_log" >&2
  rm -f "$nvim_log"
  return 1
}

# Function to configure installation profile (Desktop vs Server)
configure_profile() {
  local profile_file="$HOME_DIR/.zshrc.d/profile.zsh"
  mkdir -p "$HOME_DIR/.zshrc.d"

  # Check if DOTFILES_PROFILE is passed via environment
  if [[ -n "${DOTFILES_PROFILE:-}" ]]; then
    # Validate the environment variable
    if [[ "$DOTFILES_PROFILE" != "desktop" && "$DOTFILES_PROFILE" != "server" ]]; then
      echo "Error: Invalid DOTFILES_PROFILE '$DOTFILES_PROFILE'. Must be 'desktop' or 'server'." >&2
      exit 1
    fi

    # Check if the value in the file matches the environment variable to avoid redundant writes
    local current_file_profile=""
    if [[ -f "$profile_file" ]]; then
      # Run in a subshell, unset the env var first to ensure we read what is actually in the file.
      # Without unset, the subshell inherits the exported DOTFILES_PROFILE, masking the file content.
      current_file_profile=$(unset DOTFILES_PROFILE; source "$profile_file" >/dev/null 2>&1 && echo "${DOTFILES_PROFILE:-}")
    fi

    if [[ "$DOTFILES_PROFILE" != "$current_file_profile" ]]; then
      echo "DOTFILES_PROFILE detected in environment: $DOTFILES_PROFILE"
      echo "Saving profile to $profile_file..."
      printf 'export DOTFILES_PROFILE="%s"\n' "$DOTFILES_PROFILE" > "$profile_file"
    else
      echo "Using provided DOTFILES_PROFILE: $DOTFILES_PROFILE (matches existing configuration)"
    fi
    return
  fi

  # Load existing profile if available
  if [[ -f "$profile_file" ]]; then
    source "$profile_file"
  fi

  # Check for non-interactive shell
  if ! is_interactive; then
    if [[ -z "${DOTFILES_PROFILE:-}" ]]; then
      echo "Non-interactive shell: No profile set. Defaulting to 'server'."
      export DOTFILES_PROFILE="server"
      echo 'export DOTFILES_PROFILE="server"' > "$profile_file"
    else
      echo "Non-interactive shell: Using existing profile '$DOTFILES_PROFILE'."
    fi
    return
  fi

  if [[ -n "${DOTFILES_PROFILE:-}" ]]; then
    echo "Current profile is: $DOTFILES_PROFILE"
    read -r "response?Do you want to change the profile? [y/N] "
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
      return
    fi
  fi

  print_banner "Configuration Profile"
  echo "Select installation profile:"
  echo "1) Desktop (Full installation: GUI tools, fonts, GitHub CLI, etc.)"
  echo "2) Server (Minimal installation: Core tools only)"
  read -r "choice?Enter choice [1/2]: "

  case "$choice" in
    1)
      echo 'export DOTFILES_PROFILE="desktop"' > "$profile_file"
      export DOTFILES_PROFILE="desktop"
      echo "Profile set to Desktop."
      ;;
    2)
      echo 'export DOTFILES_PROFILE="server"' > "$profile_file"
      export DOTFILES_PROFILE="server"
      echo "Profile set to Server."
      ;;
    *)
      echo "Invalid choice. Defaulting to Server."
      echo 'export DOTFILES_PROFILE="server"' > "$profile_file"
      export DOTFILES_PROFILE="server"
      ;;
  esac
}

# Main installation routine that coordinates all tasks.
run_installation() {
  configure_profile

  print_banner "Stowing base dotfiles into $HOME_DIR"
  install_with_stow -t "$HOME_DIR" --ignore ".config/atuin/config.toml" --ignore ".gitignore" "."

  if is_desktop && [[ -d "$BASE_DIR/.local/share/fonts" ]]; then
    mkdir -p "$HOME_DIR/.local/share"
    print_banner "Stowing repository fonts into $HOME_DIR/.local/share"
    install_with_stow -t "$HOME_DIR/.local/share" -d "$BASE_DIR/.local/share" "."
    refresh_font_cache

    print_banner "Stowing private overrides from prv/"
    install_with_stow -t "$HOME_DIR" -d "prv" "."
  fi

  print_banner "Secret environment variables from Vault (optional)"
  add_secret_envs_from_vault

  print_banner "Checking Git conflict style"
  configure_git_conflict_style

  if is_desktop; then
    setup_atuin
    setup_mise_desktop_tools
    # Nie dziala idelanie , poki co koomentuje
    # setup_desktop_entries
  fi

  setup_ssh
  setup_claude

  local editor_config_file="$HOME_DIR/.zshrc.d/editor.zsh"
  mkdir -p "$HOME_DIR/.zshrc.d"

  local nvim_installed=false
  if has "nvim"; then
    local nvim_version
    nvim_version=$(nvim --version | head -n1 | grep -oE 'v[0-9]+\.[0-9]+' | sed 's/v//')
    autoload -Uz is-at-least
    if is-at-least "0.8" "$nvim_version"; then
      setup_nvim_plugins
      nvim_installed=true

      echo "Configuring Neovim as default editor..."
      cat <<EOF > "$editor_config_file"
# Generated by dotfiles install script
export VISUAL=nvim
export EDITOR=nvim
alias vim='nvim'
EOF
    else
      print_banner "Skipping Neovim setup"
      echo "Neovim version $nvim_version is too old (< 0.8). Using Vim instead."
    fi
  fi

  if [[ "$nvim_installed" == "false" ]]; then
    if has "vim"; then
      setup_vim

      echo "Configuring Vim as default editor..."
      cat <<EOF > "$editor_config_file"
# Generated by dotfiles install script
export VISUAL=vim
export EDITOR=vim
EOF
    fi
  fi

  print_banner "Installation completed successfully."
}

run_installation
