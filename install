#!/bin/zsh

# Exit immediately if a command exits with a non-zero status,
# if using an undefined variable, or if any command in a pipeline fails.
set -euo pipefail

# Determine the directory where the script is located.
SCRIPT_DIR="$(cd "$(dirname "${(%):-%x}")" && pwd)"
BASE_DIR="$SCRIPT_DIR"
HOME_DIR="$HOME"
CONFIG_DIR="$HOME_DIR/.config"

# Source shared helper functions (has, resolve_browser_cmd, etc.)
source "$BASE_DIR/.zsh/helpers.zsh"

# Optional font installer executable that mirrors the Nerd Font helper.
FONT_INSTALLER="$BASE_DIR/install-font"

# Common paths and URLs.
VAULT_URL="https://vault.8567153.xyz/v1/shell_envs/data"
VAULT_KEYS=("envs.zsh")

# Note: has() and resolve_browser_cmd() are now in .zsh/helpers.zsh

# Function to check if the profile is desktop.
is_desktop() {
  [[ "${DOTFILES_PROFILE:-server}" == "desktop" ]]
}

# Function to check if the shell is interactive.
is_interactive() {
  [[ -t 0 ]]
}

# Function to check if stdout is a TTY (for colored output).
is_tty_stdout() {
  [[ -t 1 ]]
}

# Function to print banners for major steps.
print_banner() {
  local title="$1"
  local line="========================================"
  printf "\n%s\n%s\n%s\n" "$line" "$title" "$line"
}

# Initialize ANSI colors (if supported). Respect NO_COLOR.
init_colors() {
  if ! is_tty_stdout; then
    return
  fi
  if [[ -n "${NO_COLOR:-}" ]]; then
    return
  fi

  COLOR_RED=$'\033[31m'
  COLOR_YELLOW=$'\033[33m'
  COLOR_BOLD=$'\033[1m'
  COLOR_RESET=$'\033[0m'
}

# Determine the user's login shell from the passwd database (preferred).
# Falls back to $SHELL if lookup isn't available.
get_login_shell() {
  local user="${USER:-}"
  local shell=""

  if [[ -n "$user" ]] && has "getent"; then
    shell=$(getent passwd "$user" | awk -F: '{print $7}')
  elif [[ -n "$user" ]] && [[ -r /etc/passwd ]]; then
    shell=$(awk -F: -v u="$user" '$1==u{print $7}' /etc/passwd)
  fi

  if [[ -z "$shell" ]]; then
    shell="${SHELL:-}"
  fi

  echo "$shell"
}

# Enforce zsh as the user's login shell unless explicitly overridden.
# This avoids "installation succeeded but nothing changed" when the user stays in bash.
require_zsh_login_shell() {
  if [[ "${DOTFILES_ALLOW_NON_ZSH_SHELL:-0}" == "1" ]]; then
    return
  fi

  local login_shell
  login_shell=$(get_login_shell)

  if [[ -n "$login_shell" ]] && [[ "${login_shell##*/}" == "zsh" ]]; then
    return
  fi

  print_banner "ERROR: Login shell is not zsh"
  printf "%s%s%s\n" "${COLOR_RED:-}" "!!! Aborting install to avoid confusion !!!" "${COLOR_RESET:-}"
  echo ""
  echo "Detected login shell: ${login_shell:-<unknown>}"
  echo ""
  echo "These dotfiles are primarily configured for zsh."
  echo "If you keep using bash, you may not see any changes after installation."
  echo ""
  echo "Fix (recommended):"
  printf "  %schsh -s \"%s\"%s\n" "${COLOR_BOLD:-}" "$(command -v zsh)" "${COLOR_RESET:-}"
  echo "  Then log out and log back in (or reboot)."
  echo ""
  echo "On some systems (e.g. Raspberry Pi OS), you may need:"
  printf "  %ssudo chsh -s \"%s\" \"%s\"%s\n" "${COLOR_BOLD:-}" "$(command -v zsh)" "$USER" "${COLOR_RESET:-}"
  echo ""
  echo "Temporary (current session only):"
  printf "  %sexec zsh -l%s\n" "${COLOR_BOLD:-}" "${COLOR_RESET:-}"
  echo ""
  printf "%sOverride (not recommended):%s\n" "${COLOR_YELLOW:-}" "${COLOR_RESET:-}"
  echo "  DOTFILES_ALLOW_NON_ZSH_SHELL=1 ./install"
  exit 1
}

# Function to install symlinks using stow.
install_with_stow() {
  local stow_opts=("$@")

  echo "Running stow with: ${stow_opts[*]}"
  if ! stow -v "${stow_opts[@]}" -n; then
    echo "Error: Stow dry run failed with options: ${stow_opts[*]}" >&2
    exit 1
  fi

  # Auto-apply in non-interactive mode
  if ! is_interactive; then
    echo "Non-interactive mode detected. Applying changes automatically..."
    stow -v "${stow_opts[@]}"
    return
  fi

  read -r "response?Do you want to apply the changes? [y/N] "
  case "$response" in
    [Yy]*)
      echo "Applying changes..."
      stow -v "${stow_opts[@]}"
      ;;
    *)
      echo "Changes were not applied."
      ;;
  esac
}

# Function to force-refresh the font cache when fonts are (re)linked.
refresh_font_cache() {
  local font_dir="$HOME_DIR/.local/share/fonts"

  if ! has "fc-cache"; then
    echo "fc-cache not available; cannot refresh font cache." >&2
    exit 1
  fi

  if [[ ! -d "$font_dir" ]]; then
    echo "Font directory $font_dir not found; cannot refresh font cache." >&2
    exit 1
  fi

  print_banner "Refreshing font cache..."
  fc-cache -f "$font_dir"
}

# Function to add secret environment variables from Vault.
# Sets VAULT_TOKEN globally for reuse by other functions (e.g., setup_rclone).
add_secret_envs_from_vault() {
  if ! is_interactive; then
    echo "Skipping secret envs setup in non-interactive mode."
    return
  fi

  read -r "response?Would you like to add secret envs from Vault? [y/N] "
  if [[ ! "$response" =~ ^[Yy]$ ]]; then
    echo "Skipped adding secret environment variables from Vault."
    return
  fi

  read -rs "VAULT_TOKEN?Please provide your Vault token: "
  echo
  export VAULT_TOKEN

  # Ensure restrictive permissions for secrets directory
  (umask 077 && mkdir -p "$HOME_DIR/.zshrc.d")
  chmod 700 "$HOME_DIR/.zshrc.d"

  for key in "${VAULT_KEYS[@]}"; do
    echo "Fetching data for key: $key"

    local vault_response
    vault_response=$(curl -sf -H "X-Vault-Token: $VAULT_TOKEN" -X GET "$VAULT_URL/$key") || {
      echo "Failed to fetch data for $key from Vault." >&2
      continue
    }

    local target_file="$HOME_DIR/.zshrc.d/$key"
    echo "# Generated with install script from dotfiles" > "$target_file"
    # Use @sh for safe quoting to prevent injection from special characters
    echo "$vault_response" | jq -r '.data.data | to_entries[] | "export " + .key + "=" + (.value | @sh)' >> "$target_file"
    chmod 600 "$target_file"

    echo "Environment variables for $key have been saved to $target_file"
  done
}

# Function to configure Git conflict style based on git version.
configure_git_conflict_style() {
  local required_git_version="2.35.0"
  local current_version
  current_version=$(git --version | awk '{print $3}')

  autoload -Uz is-at-least
  if is-at-least "$required_git_version" "$current_version"; then
    echo "Git version ($current_version) supports zdiff3."
    git config --file "$HOME_DIR/.gitconfig.local" merge.conflictstyle "zdiff3"
    echo "Set 'merge.conflictstyle' to 'zdiff3' in $HOME_DIR/.gitconfig.local."
  fi
}

# Function to setup Atuin configuration.
setup_atuin() {
  print_banner "Setting up Atuin configuration..."
  mkdir -p "$CONFIG_DIR/atuin/"
  local src="$BASE_DIR/.config/atuin/config.toml"
  local dst="$CONFIG_DIR/atuin/config.toml"

  # Skip if already correctly linked
  if [[ -e "$dst" ]] && [[ "$(readlink -f "$dst")" == "$(readlink -f "$src")" ]]; then
    return
  fi

  ln -sfn "$src" "$dst"
}

# Function to ensure SSH directories exist.
setup_ssh() {
  print_banner "Ensuring SSH configuration directory exists..."
  mkdir -p "$HOME_DIR/.ssh/config.d/"
}

# Function to install custom desktop entries defined in webapps/apps.tsv.
setup_desktop_entries() {
  set -euo pipefail

  if ! is_desktop; then
    echo "Skipping desktop entry installation on non-desktop profile."
    return
  fi

  local config="$BASE_DIR/webapps/apps.tsv"
  if [[ ! -f "$config" ]]; then
    echo "No desktop entry config found at $config; skipping."
    return
  fi

  local applications_dir="${XDG_DATA_HOME:-$HOME_DIR/.local/share}/applications"
  local icon_dir="$applications_dir/icons"
  mkdir -p "$applications_dir" "$icon_dir"

  local desktop_installer=""
  if has "desktop-file-install"; then
    desktop_installer="desktop-file-install"
  else
    echo "desktop-file-install not found; will write .desktop files directly."
  fi

  local browser_cmd
  browser_cmd=$(resolve_browser_cmd)

  if [[ -z "$browser_cmd" ]]; then
    echo "No supported browser found (set BROWSER or install Brave/Chrome/Chromium); skipping desktop entries."
    return
  fi

  print_banner "Installing desktop entries"
  [[ -o xtrace ]] && echo "DEBUG xtrace before loop"

  local global_flags="${DOTFILES_BROWSER_FLAGS:-}"
  local enable_wayland="${DOTFILES_CHROMIUM_WAYLAND:-1}"
  local desired_slugs=()

  while IFS='|' read -r name slug app_url icon_filename extra_flags _; do
    # Skip comments/empty lines
    if [[ -z "${name// }" ]] || [[ "${name:0:1}" == "#" ]]; then
      continue
    fi

    if [[ -z "$slug" || -z "$app_url" ]]; then
      echo "Skipping entry with missing slug or app_url: $name"
      continue
    fi

    desired_slugs+=("$slug")

    local icon_name="dotfiles-$slug"
    local desktop_file="$applications_dir/dotfiles-$slug.desktop"
    local tmpdir tmpfile
    tmpdir=$(mktemp -d -t "dotfiles-$slug.XXXXXX")
    tmpfile="$tmpdir/dotfiles-$slug.desktop"

    local exec_cmd="$browser_cmd --new-window --app=$app_url --name=${name// /\\ } --class=$slug"
    if [[ "$enable_wayland" == "1" ]]; then
      exec_cmd+=" --ozone-platform=wayland"
    fi
    if [[ -n "$global_flags" ]]; then
      exec_cmd+=" $global_flags"
    fi
    if [[ -n "$extra_flags" ]]; then
      exec_cmd+=" $extra_flags"
    fi

    if [[ -z "$icon_filename" ]]; then
      echo "Missing icon filename for $slug (column 4 in $config)."
      return 1
    fi

    local repo_icon="$BASE_DIR/webapps/icons/$icon_filename"
    local installed_icon="$icon_dir/${icon_name}.png"
    if [[ ! -f "$repo_icon" ]]; then
      echo "Icon file '$icon_filename' not found in webapps/icons for $slug."
      return 1
    fi

    install -m 0644 "$repo_icon" "$installed_icon"

    cat > "$tmpfile" <<EOF
[Desktop Entry]
Version=1.0
Name=$name
Comment=$name (PWA)
Exec=$exec_cmd
Terminal=false
Type=Application
Categories=Network;
Icon=$icon_name
StartupWMClass=$slug
StartupNotify=true
EOF

    if [[ -n "$desktop_installer" ]]; then
      "$desktop_installer" --dir "$applications_dir" --mode 0644 "$tmpfile"
    else
      install -m 0644 "$tmpfile" "$desktop_file"
    fi
    rm -rf "$tmpdir"

    echo "Installed dotfiles-$slug.desktop using browser: $browser_cmd"
  done < "$config"

  print_banner "Checking stale desktop entries"
  setopt localoptions null_glob
  local to_remove=()
  for file in "$applications_dir"/dotfiles-*.desktop; do
    local slug
    slug=${file##*/dotfiles-}
    slug=${slug%.desktop}
    local found=false
    for desired in "${desired_slugs[@]}"; do
      if [[ "$slug" == "$desired" ]]; then
        found=true
        break
      fi
    done
    if [[ "$found" == false ]]; then
      to_remove+=("$file")
    fi
  done

  if (( ${#to_remove[@]} )); then
    echo "Found stale dotfiles desktop entries:"
    printf ' - %s\n' "${to_remove[@]}"
    if is_interactive; then
      read -r "response?Remove them now? [y/N] "
      if [[ "$response" =~ ^[Yy]$ ]]; then
        rm -f "${to_remove[@]}"
        echo "Removed stale entries."
      else
        echo "Leaving stale entries in place."
      fi
    else
      echo "Non-interactive mode: not removing stale entries."
    fi
  fi
}

# Function to install desktop-specific tools via mise.
setup_mise_desktop_tools() {
  if ! has "mise"; then
    echo "mise not found; skipping mise desktop tools."
    return
  fi

  print_banner "Installing desktop tools via mise..."
  # Keep desktop-scoped tools in one place for predictable onboarding.
  local mise_tools=(
    "gem:tmuxinator"
    # The ubi backend is deprecated in mise docs.
    # Use github:owner/repo for GitHub Releases-based tools.
    "github:cli/cli@latest"
    "github:openai/codex[asset_pattern=codex-x86_64-unknown-linux-musl.tar.gz,rename_exe=codex]@latest"
    "github:steipete/gogcli@latest"
    "github:yt-dlp/yt-dlp[asset_pattern=yt-dlp_linux.zip,rename_exe=yt-dlp]@latest"
  )

  local tool=""
  for tool in "${mise_tools[@]}"; do
    mise use -g "$tool"
  done
}

# Function to setup rclone configuration from Vault (desktop only).
setup_rclone() {
  if ! is_desktop; then
    return
  fi

  if ! is_interactive; then
    echo "Skipping rclone setup in non-interactive mode."
    return
  fi

  local template="$BASE_DIR/.config/rclone/rclone.conf.template"
  if [[ ! -f "$template" ]]; then
    return
  fi

  read -r "response?Would you like to setup rclone with password from Vault? [y/N] "
  if [[ ! "$response" =~ ^[Yy]$ ]]; then
    echo "Skipping rclone config setup."
    return
  fi

  print_banner "Setting up rclone configuration..."

  local rclone_dir="$CONFIG_DIR/rclone"
  local target="$rclone_dir/rclone.conf"
  mkdir -p "$rclone_dir"

  # Use existing VAULT_TOKEN or prompt for one
  if [[ -z "${VAULT_TOKEN:-}" ]]; then
    read -rs "VAULT_TOKEN?Please provide your Vault token: "
    echo
  fi

  # Fetch rclone password from Vault (stored in secret/configs/rclone)
  local vault_url_base="${VAULT_URL%/shell_envs/data}"
  local vault_response
  vault_response=$(curl -sf -H "X-Vault-Token: $VAULT_TOKEN" -X GET "$vault_url_base/secret/data/configs/rclone") || {
    echo "Failed to fetch rclone secrets from Vault." >&2
    return 1
  }

  local nas_pass
  nas_pass=$(echo "$vault_response" | jq -r '.data.data.nas_pass')

  if [[ -z "$nas_pass" || "$nas_pass" == "null" ]]; then
    echo "nas_pass not found in Vault at secret/configs/rclone." >&2
    return 1
  fi

  # Generate config from template
  sed "s|{{nas_pass}}|$nas_pass|g" "$template" > "$target"
  chmod 600 "$target"

  echo "rclone config generated at $target"
}

# Function to setup Claude Code configuration via stow.
# Uses stow to link .claude contents (skills/, settings.json, scripts) into ~/.claude/.
# settings.local.json is ignored (per-project file for this dotfiles repo).
setup_claude() {
  print_banner "Setting up Claude Code configuration..."
  local claude_dir="$HOME_DIR/.claude"

  mkdir -p "$claude_dir"

  # Use stow to link .claude package contents into ~/.claude
  # --ignore: skip settings.local.json (per-project) and skills/ (managed via prv/.agents)
  install_with_stow -d "$BASE_DIR" -t "$claude_dir" \
    --ignore='settings\.local\.json' \
    --ignore='^skills$' \
    .claude
}

# Function to setup Codex configuration via stow.
# Uses stow to link .codex contents (scripts) into ~/.codex/.
setup_codex() {
  print_banner "Setting up Codex configuration..."
  local codex_dir="$HOME_DIR/.codex"

  mkdir -p "$codex_dir"

  # Use stow to link .codex package contents into ~/.codex
  install_with_stow -d "$BASE_DIR" -t "$codex_dir" .codex
}

# Function to setup Vim autoload directories and plugins.
setup_vim() {
  print_banner "Setting up Vim..."
  mkdir -p "$HOME_DIR/.vim/"{autoload,undo,swapfiles,backupfiles}
  curl -fsSLo "$HOME_DIR/.vim/autoload/plug.vim" --create-dirs "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim"
  vim +PlugInstall +qall
}

# Function to install Neovim plugins via lazy.nvim while Neovim is available.
setup_nvim_plugins() {
  local nvim_log
  nvim_log=$(mktemp -t install-nvim-sync.XXXXXX)

  print_banner "Installing Neovim plugins via lazy.nvim..."
  if nvim --headless -c 'Lazy! sync' -c 'qa' >"$nvim_log" 2>&1; then
    rm -f "$nvim_log"
    return
  fi

  echo "Neovim lazy sync failed; output follows:" >&2
  cat "$nvim_log" >&2
  rm -f "$nvim_log"
  return 1
}

# Function to configure installation profile (Desktop vs Server)
configure_profile() {
  local profile_file="$HOME_DIR/.zshrc.d/profile.zsh"
  mkdir -p "$HOME_DIR/.zshrc.d"

  # Check if DOTFILES_PROFILE is passed via environment
  if [[ -n "${DOTFILES_PROFILE:-}" ]]; then
    # Validate the environment variable
    if [[ "$DOTFILES_PROFILE" != "desktop" && "$DOTFILES_PROFILE" != "server" ]]; then
      echo "Error: Invalid DOTFILES_PROFILE '$DOTFILES_PROFILE'. Must be 'desktop' or 'server'." >&2
      exit 1
    fi

    # Check if the value in the file matches the environment variable to avoid redundant writes
    local current_file_profile=""
    if [[ -f "$profile_file" ]]; then
      # Run in a subshell, unset the env var first to ensure we read what is actually in the file.
      # Without unset, the subshell inherits the exported DOTFILES_PROFILE, masking the file content.
      current_file_profile=$(unset DOTFILES_PROFILE; source "$profile_file" >/dev/null 2>&1 && echo "${DOTFILES_PROFILE:-}")
    fi

    if [[ "$DOTFILES_PROFILE" != "$current_file_profile" ]]; then
      echo "DOTFILES_PROFILE detected in environment: $DOTFILES_PROFILE"
      echo "Saving profile to $profile_file..."
      printf 'export DOTFILES_PROFILE="%s"\n' "$DOTFILES_PROFILE" > "$profile_file"
    else
      echo "Using provided DOTFILES_PROFILE: $DOTFILES_PROFILE (matches existing configuration)"
    fi
    return
  fi

  # Load existing profile if available
  if [[ -f "$profile_file" ]]; then
    source "$profile_file"
  fi

  # Check for non-interactive shell
  if ! is_interactive; then
    if [[ -z "${DOTFILES_PROFILE:-}" ]]; then
      echo "Non-interactive shell: No profile set. Defaulting to 'server'."
      export DOTFILES_PROFILE="server"
      echo 'export DOTFILES_PROFILE="server"' > "$profile_file"
    else
      echo "Non-interactive shell: Using existing profile '$DOTFILES_PROFILE'."
    fi
    return
  fi

  if [[ -n "${DOTFILES_PROFILE:-}" ]]; then
    echo "Current profile is: $DOTFILES_PROFILE"
    read -r "response?Do you want to change the profile? [y/N] "
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
      return
    fi
  fi

  print_banner "Configuration Profile"
  echo "Select installation profile:"
  echo "1) Desktop (Full installation: GUI tools, fonts, GitHub CLI, etc.)"
  echo "2) Server (Minimal installation: Core tools only)"
  read -r "choice?Enter choice [1/2]: "

  case "$choice" in
    1)
      echo 'export DOTFILES_PROFILE="desktop"' > "$profile_file"
      export DOTFILES_PROFILE="desktop"
      echo "Profile set to Desktop."
      ;;
    2)
      echo 'export DOTFILES_PROFILE="server"' > "$profile_file"
      export DOTFILES_PROFILE="server"
      echo "Profile set to Server."
      ;;
    *)
      echo "Invalid choice. Defaulting to Server."
      echo 'export DOTFILES_PROFILE="server"' > "$profile_file"
      export DOTFILES_PROFILE="server"
      ;;
  esac
}

# Main installation routine that coordinates all tasks.
run_installation() {
  configure_profile

  init_colors
  require_zsh_login_shell

  print_banner "Stowing base dotfiles into $HOME_DIR"
  install_with_stow -t "$HOME_DIR" --ignore ".config/atuin/config.toml" --ignore ".gitignore" "."

  # Interactive prompts first (before long-running tasks like font cache)
  print_banner "Secret environment variables from Vault (optional)"
  add_secret_envs_from_vault

  setup_rclone

  # Enable rclone systemd service (after stow linked it and rclone.conf exists)
  if is_desktop && [[ -f "$CONFIG_DIR/systemd/user/rclone-nas.service" ]] && [[ -f "$CONFIG_DIR/rclone/rclone.conf" ]]; then
    if [[ ! -d /mnt/nas ]]; then
      echo "Note: /mnt/nas missing. See README.md for first-time setup."
    fi
    echo "Enabling rclone services..."
    systemctl --user daemon-reload
    systemctl --user enable rclone-nas.service 2>/dev/null || true
    systemctl --user enable rclone-sleep-handler.service 2>/dev/null || true
  fi

  # Private overrides and fonts after all Y/N prompts (font cache takes time)
  if is_desktop; then
    print_banner "Stowing private overrides from prv/"
    install_with_stow -t "$HOME_DIR" -d "prv" "."

    # Stow user scripts from .local/bin
    if [[ -d "$BASE_DIR/.local/bin" ]]; then
      mkdir -p "$HOME_DIR/.local/bin"
      print_banner "Stowing scripts into $HOME_DIR/.local/bin"
      install_with_stow -t "$HOME_DIR/.local/bin" -d "$BASE_DIR/.local/bin" "."
    fi

    if [[ -d "$BASE_DIR/.local/share/fonts" ]]; then
      mkdir -p "$HOME_DIR/.local/share"
      print_banner "Stowing repository fonts into $HOME_DIR/.local/share"
      install_with_stow -t "$HOME_DIR/.local/share" -d "$BASE_DIR/.local/share" "."
      refresh_font_cache
    fi
  fi

  print_banner "Checking Git conflict style"
  configure_git_conflict_style

  if is_desktop; then
    setup_atuin
    setup_mise_desktop_tools
    setup_claude
    setup_codex
    # Nie dziala idelanie , poki co koomentuje
    # setup_desktop_entries
  fi

  setup_ssh

  local editor_config_file="$HOME_DIR/.zshrc.d/editor.zsh"
  mkdir -p "$HOME_DIR/.zshrc.d"

  local nvim_installed=false
  if has "nvim"; then
    local nvim_version
    nvim_version=$(nvim --version | head -n1 | grep -oE 'v[0-9]+\.[0-9]+' | sed 's/v//')
    autoload -Uz is-at-least
    if is-at-least "0.8" "$nvim_version"; then
      setup_nvim_plugins
      nvim_installed=true

      echo "Configuring Neovim as default editor..."
      cat <<EOF > "$editor_config_file"
# Generated by dotfiles install script
export VISUAL=nvim
export EDITOR=nvim
alias vim='nvim'
EOF
    else
      print_banner "Skipping Neovim setup"
      echo "Neovim version $nvim_version is too old (< 0.8). Using Vim instead."
    fi
  fi

  if [[ "$nvim_installed" == "false" ]]; then
    if has "vim"; then
      setup_vim

      echo "Configuring Vim as default editor..."
      cat <<EOF > "$editor_config_file"
# Generated by dotfiles install script
export VISUAL=vim
export EDITOR=vim
EOF
    fi
  fi

  print_banner "Installation completed successfully."
}

run_installation
